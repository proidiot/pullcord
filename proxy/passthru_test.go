package proxy

import (
	"encoding/json"
	"fmt"
	"github.com/fitstar/falcore"
	"github.com/proidiot/gone/errors"
	"github.com/stretchr/testify/assert"
	configutil "github.com/stuphlabs/pullcord/config/util"
	"github.com/stuphlabs/pullcord/util"
	"io/ioutil"
	"net/http"
	"regexp"
	"testing"
)

// serveLandingPage is a testing helper function that creates a webserver that
// other tests for NewPassthruFilter can use to verify expected proxying
// behaviors.
func serveLandingPage(landingServer *falcore.Server) {
	err := landingServer.ListenAndServe()
	if err != nil {
		panic(err)
	}
}

// TestPassthru verifies that a Falcore RequestFilter generated by
// NewPassthruFilter will forward web traffic as expected.
func TestPassthru(t *testing.T) {
	request, err := http.NewRequest("GET", "http://localhost", nil)
	assert.NoError(t, err)

	landingPipeline := falcore.NewPipeline()
	landingPipeline.Upstream.PushBack(&util.LandingFilter{})

	landingServer := falcore.NewServer(0, landingPipeline)

	regex, err := regexp.Compile("Pullcord Landing Page")
	assert.NoError(t, err)

	go serveLandingPage(landingServer)
	defer landingServer.StopAccepting()

	<- landingServer.AcceptReady

	_, response := falcore.TestWithRequest(
		request,
		NewPassthruFilter("localhost", landingServer.Port()),
		nil,
	)
	assert.Equal(t, 200, response.StatusCode)
	contents, err := ioutil.ReadAll(response.Body)
	assert.NoError(t, err)
	assert.True(t, regex.Match(contents))
}

func TestPassthruFilterFromConfig(t *testing.T) {
	test := configutil.ConfigTest{
		ResourceType: "passthrufilter",
		IsValid: func(i json.Unmarshaler) error {
			var p *PassthruFilter

			switch i := i.(type) {
			case *PassthruFilter:
				p = i
			default:
				return errors.New(
					fmt.Sprintf(
						"PassthruFilter IsValid" +
						" received an object that" +
						" doesn't have the type" +
						" PassthruFilter: %v",
						i,
					),
				)
			}

			if p.Host == "" {
				return errors.New(
					"PassthruFilter IsValid received a" +
					" PassthruFilter with an empty host.",
				)
			}

			if p.Port <= 0 {
				return errors.New(
					fmt.Sprintf(
						"PassthruFilter IsValid" +
						" received a PassthruFilter" +
						" with a bad port: %d",
						p.Port,
					),
				)
			}

			if p.upstreamFilter == nil {
				return errors.New(
					"PassthruFilter IsValid received a" +
					" PassthruFilter with an" +
					" uninitialized upstream filter.",
				)
			}

			return nil
		},
		SyntacticallyBad: []configutil.ConfigTestData{
			configutil.ConfigTestData{
				Data: "",
				Explanation: "empty config",
			},
			configutil.ConfigTestData{
				Data: `{
					"host": 7,
					"port": 11
				}`,
				Explanation: "numeric host",
			},
			configutil.ConfigTestData{
				Data: `{
					"host": "127.0.0.1",
					"port": "8080"
				}`,
				Explanation: "string port",
			},
			configutil.ConfigTestData{
				Data: "42",
				Explanation: "numeric config",
			},
		},
		SemanticallyBad: []configutil.ConfigTestData{
			configutil.ConfigTestData{
				Data: "{}",
				Explanation: "empty object",
			},
			configutil.ConfigTestData{
				Data: "null",
				Explanation: "null config",
			},
			configutil.ConfigTestData{
				Data: `{
					"host": "127.0.0.1",
					"port": -80
				}`,
				Explanation: "negative port",
			},
		},
		Good: []configutil.ConfigTestData{
			configutil.ConfigTestData{
				Data: `{
					"host": "127.0.0.1",
					"port": 80
				}`,
				Explanation: "basic valid proxy config",
			},
		},
	}
	test.Run(t)
}
