package monitor

import (
	//"bufio"
	"context"
	"fmt"
	"io/ioutil"
	"net"
	"net/http"
	"net/http/httptest"
	"net/url"
	//"os"
	//"strconv"
	"strings"
	"testing"
	"time"

	"github.com/proidiot/gone/errors"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	configutil "github.com/stuphlabs/pullcord/config/util"
	"github.com/stuphlabs/pullcord/util"
)

func getFreshLandingResponder(t *testing.T) (*url.URL, *http.Server, error) {
	lc := &net.ListenConfig{
		KeepAlive: -1,
	}
	l, e := lc.Listen(context.Background(), "tcp", "localhost:0")
	if e != nil {
		return nil, nil, e
	}

	uniAddr := l.Addr()
	uniAddrString := uniAddr.String()
	portOffset := strings.LastIndex(uniAddrString, ":")
	if portOffset < 0 {
		return nil, nil, fmt.Errorf(
			"Address string has unexpected format: %s",
			uniAddrString,
		)
	}
	host := uniAddrString[:portOffset]
	if host == "0.0.0.0" {
		host = "127.0.0.1"
	} else if host == "[::]" {
		host = "[::1]"
	}
	port := uniAddrString[portOffset+1:]

	u, e := url.Parse(fmt.Sprintf("http://%s:%s/", host, port))
	if e != nil {
		return nil, nil, e
	}

	s := &http.Server{
		Handler: new(util.LandingHandler),
	}

	go func(t *testing.T, s *http.Server, l net.Listener) {
		requiredErr := http.ErrServerClosed
		actualErr := s.Serve(l)
		require.Equalf(
			t,
			requiredErr,
			actualErr,
			"Unable to serve HTTP required by tests",
		)
	}(t, s, l)

	return u, s, nil
}

func getUpService(t *testing.T) (*url.URL, *http.Server, error) {
	// TODO recycle services
	return getFreshLandingResponder(t)
}

func recycleUpService(s *http.Server) {
	// TODO recycle services
	_ = s.Close()
}

var _downService *url.URL

func getDownService(t *testing.T) (*url.URL, error) {
	if _downService == nil {
		/*
		u, e := url.Parse("//127.0.0.1:2")
		if e != nil {
			return nil, e
		}
		_downService = u
		*/
		u, s, e := getUpService(t)
		if e != nil {
			return nil, e
		}
		s.Close()

		/*
		d, e := getTCPTimeout()
		if e != nil {
			return nil, e
		}
		t.Logf(
			"Sleeping for %s so that the test socket can close",
			d.String(),
		)
		time.Sleep(d)
		*/

		_downService = u
	}

	return _downService, nil
}

// TestMinMonitorUpService verifies that a MinMonitor generated by
// NewMinMonitor will give the expected status for a service that is up.
func TestMinMonitorUpService(t *testing.T) {
	testServiceName := "test"
	gracePeriod := time.Duration(0)

	u, s, err := getUpService(t)
	require.NoError(t, err)
	defer recycleUpService(s)

	service := &MinMonitorredService{
		URL: u,
		GracePeriod: gracePeriod,
	}
	assert.NoError(t, err)
	mon := MinMonitor{}
	err = mon.Add(
		testServiceName,
		service,
	)
	assert.NoError(t, err)

	up, err := mon.Status(testServiceName)
	assert.NoError(t, err)
	assert.True(t, up)
}

// TestMinMonitorDownService verifies that a MinMonitor generated by
// NewMinMonitor will give the expected status for a service that is down.
func TestMinMonitorDownService(t *testing.T) {
	testServiceName := "test"
	gracePeriod := time.Duration(0)

	u, err := getDownService(t)
	assert.NoError(t, err)

	svc := &MinMonitorredService{
		URL: u,
		GracePeriod: gracePeriod,
	}
	assert.NoError(t, err)
	mon := MinMonitor{}
	err = mon.Add(
		testServiceName,
		svc,
	)
	assert.NoError(t, err)

	up, err := mon.Status(testServiceName)
	assert.NoError(t, err)
	assert.False(t, up)
}

// TestMinMonitorInvalidService verifies that a MinMonitor generated by
// NewMinMonitor will give the expected status for a service that is invalid.
func TestMinMonitorInvalidService(t *testing.T) {
	testServiceName := "test"

	u, err := url.Parse("//127.0.0.1:80")
	assert.NoError(t, err)
	u.Host = "256.256.256.256.256:65536"

	gracePeriod := time.Duration(0)

	svc := &MinMonitorredService{
		URL: u,
		GracePeriod: gracePeriod,
	}
	assert.NoError(t, err)
	mon := MinMonitor{}
	err = mon.Add(
		testServiceName,
		svc,
	)
	assert.NoError(t, err)

	up, err := mon.Status(testServiceName)
	assert.Error(t, err)
	assert.False(t, up)
}

// TestMinMonitorUpReprobe verifies that a MinMonitor generated by
// NewMinMonitor will give the expected status for a good reprobe.
func TestMinMonitorUpReprobe(t *testing.T) {
	testServiceName := "test"

	u, s, err := getUpService(t)
	assert.NoError(t, err)
	defer recycleUpService(s)

	gracePeriod := time.Duration(0)

	svc := &MinMonitorredService{
		URL: u,
		GracePeriod: gracePeriod,
	}
	assert.NoError(t, err)
	mon := MinMonitor{}
	err = mon.Add(
		testServiceName,
		svc,
	)
	assert.NoError(t, err)

	up, err := mon.Reprobe(testServiceName)
	assert.NoError(t, err)
	assert.True(t, up)
}

// TestMinMonitorDownReprobe verifies that a MinMonitor generated by
// NewMinMonitor will give the expected status for a failed reprobe.
func TestMinMonitorDownReprobe(t *testing.T) {
	testServiceName := "test"

	u, err := getDownService(t)
	assert.NoError(t, err)

	gracePeriod := time.Duration(0)

	svc := &MinMonitorredService{
		URL: u,
		GracePeriod: gracePeriod,
	}
	assert.NoError(t, err)
	mon := MinMonitor{}
	err = mon.Add(
		testServiceName,
		svc,
	)
	assert.NoError(t, err)

	up, err := mon.Reprobe(testServiceName)
	assert.NoError(t, err)
	assert.False(t, up)
}

// TestMinMonitorSetStatusUp verifies that a MinMonitor generated by
// NewMinMonitor will give the expected status for a seemingly down service
// that is specifically indicated as being up.
func TestMinMonitorSetStatusUp(t *testing.T) {
	testServiceName := "test"

	u, err := getDownService(t)
	assert.NoError(t, err)

	// an amount of time longer than it will take to do successive reprobes
	gracePeriod, err := time.ParseDuration("30s")
	assert.NoError(t, err)

	svc := &MinMonitorredService{
		URL: u,
		GracePeriod: gracePeriod,
	}
	assert.NoError(t, err)
	mon := MinMonitor{}
	err = mon.Add(
		testServiceName,
		svc,
	)
	assert.NoError(t, err)

	up, err := mon.Status(testServiceName)
	assert.NoError(t, err)
	assert.False(t, up)

	err = mon.SetStatusUp(testServiceName)
	assert.NoError(t, err)

	up, err = mon.Status(testServiceName)
	assert.NoError(t, err)
	assert.True(t, up)
}

// TestMinMonitorFalsePositive verifies that a MinMonitor generated by
// NewMinMonitor will give the expected status for a service that is goes down
// but is reprobed within the grace period.
func TestMinMonitorFalsePositive(t *testing.T) {
	testServiceName := "test"

	u, s, err := getUpService(t)
	assert.NoError(t, err)

	// an amount of time longer than it will take to do successive reprobes
	gracePeriod, err := time.ParseDuration("30s")
	assert.NoError(t, err)

	service := &MinMonitorredService{
		URL: u,
		GracePeriod: gracePeriod,
	}
	assert.NoError(t, err)
	mon := MinMonitor{}
	err = mon.Add(
		testServiceName,
		service,
	)
	assert.NoError(t, err)

	up, err := mon.Status(testServiceName)
	assert.NoError(t, err)
	assert.True(t, up)

	err = s.Close()
	assert.NoError(t, err)

	up, err = mon.Status(testServiceName)
	assert.NoError(t, err)
	assert.True(t, up)
}

// TestMinMonitorTrueNegative verifies that a MinMonitor generated by
// NewMinMonitor will give the expected status for a service that is up.
func TestMinMonitorTrueNegative(t *testing.T) {
	testServiceName := "test"

	u, s, err := getUpService(t)
	assert.NoError(t, err)

	gracePeriod := time.Duration(0)

	service := &MinMonitorredService{
		URL: u,
		GracePeriod: gracePeriod,
	}
	assert.NoError(t, err)
	mon := MinMonitor{}
	err = mon.Add(
		testServiceName,
		service,
	)
	assert.NoError(t, err)

	up, err := mon.Status(testServiceName)
	assert.NoError(t, err)
	assert.True(t, up)

	err = s.Close()
	assert.NoError(t, err)

	/*
	// The socket is kept open for an amount of time after being prompted
	// to close in case any more TCP packets show up. Unfortunately we'll
	// just have to wait.
	sleepDuration, _ := getTCPTimeout()
	//require.NoError(t, err)
	t.Logf(
		"Sleeping for %s so that the test socket can close",
		sleepDuration.String(),
	)
	time.Sleep(sleepDuration)
	*/

	up, err = mon.Status(testServiceName)
	assert.NoError(t, err)
	assert.False(t, up)
}

// TestMinMonitorNonExistantStatus verifies that a MinMonitor generated by
// NewMinMonitor will give the expected status for a service that is
// unspecified.
func TestMinMonitorNonExistantStatus(t *testing.T) {
	testServiceName := "test"

	mon := MinMonitor{}

	up, err := mon.Status(testServiceName)
	assert.Error(t, err)
	assert.Equal(t, UnknownServiceError, err)
	assert.False(t, up)
}

// TestMinMonitorNonExistantSetStatusUp verifies that a MinMonitor generated by
// NewMinMonitor will give the expected status during an attempt to explicitly
// set an up state for a service that is unspecified.
func TestMinMonitorNonExistantSetStatusUp(t *testing.T) {
	testServiceName := "test"

	mon := MinMonitor{}

	err := mon.SetStatusUp(testServiceName)
	assert.Error(t, err)
	assert.Equal(t, UnknownServiceError, err)
}

// TestMinMonitorNonExistantReprobe verifies that a MinMonitor generated by
// NewMinMonitor will give the expected status during a reprobe attempt for a
// service that is unspecified.
func TestMinMonitorNonExistantReprobe(t *testing.T) {
	testServiceName := "test"

	mon := MinMonitor{}

	up, err := mon.Reprobe(testServiceName)
	assert.Error(t, err)
	assert.Equal(t, UnknownServiceError, err)
	assert.False(t, up)
}

// TestMinMonitorAddExistant verifies that a MinMonitor generated by
// NewMinMonitor will give the expected status when attempting to add two
// monitored services with the same name.
func TestMinMonitorAddExistant(t *testing.T) {
	testServiceName := "test"

	u, s, err := getUpService(t)
	assert.NoError(t, err)
	defer recycleUpService(s)

	gracePeriod := time.Duration(0)

	svc := &MinMonitorredService{
		URL: u,
		GracePeriod: gracePeriod,
	}
	assert.NoError(t, err)
	mon := MinMonitor{}
	err = mon.Add(
		testServiceName,
		svc,
	)
	assert.NoError(t, err)

	u2, err := url.Parse(fmt.Sprintf("%s0", u.String()))
	assert.NoError(t, err)

	svc2 := &MinMonitorredService{
		URL: u2,
		GracePeriod: gracePeriod,
	}
	assert.NoError(t, err)
	err = mon.Add(
		testServiceName,
		svc2,
	)
	assert.Error(t, err)
	assert.Equal(t, DuplicateServiceRegistrationError, err)
}

func TestMonitorFilterUp(t *testing.T) {
	request, err := http.NewRequest("GET", "http://localhost", nil)
	assert.NoError(t, err)

	testServiceName := "test"

	u, s, err := getUpService(t)
	assert.NoError(t, err)
	defer recycleUpService(s)

	gracePeriod := time.Duration(0)

	service := &MinMonitorredService{
		URL: u,
		GracePeriod: gracePeriod,
	}
	assert.NoError(t, err)
	mon := MinMonitor{}
	err = mon.Add(
		testServiceName,
		service,
	)
	assert.NoError(t, err)

	filter, err := mon.NewMinMonitorFilter(testServiceName)
	assert.NoError(t, err)

	recorder := httptest.NewRecorder()
	filter.ServeHTTP(recorder, request)
	response := recorder.Result()

	assert.Equal(t, 200, response.StatusCode)
	contents, err := ioutil.ReadAll(response.Body)
	assert.NoError(t, err)
	assert.True(
		t,
		strings.Contains(string(contents), "Pullcord Landing Page"),
		"content is: "+string(contents),
	)
}

func TestMonitorFilterDown(t *testing.T) {
	request, err := http.NewRequest("GET", "http://localhost", nil)
	assert.NoError(t, err)

	testServiceName := "test"

	u, err := getDownService(t)
	assert.NoError(t, err)

	gracePeriod := time.Duration(0)

	svc := &MinMonitorredService{
		URL: u,
		GracePeriod: gracePeriod,
	}
	assert.NoError(t, err)
	mon := MinMonitor{}
	err = mon.Add(
		testServiceName,
		svc,
	)
	assert.NoError(t, err)

	filter, err := mon.NewMinMonitorFilter(testServiceName)
	assert.NoError(t, err)

	recorder := httptest.NewRecorder()
	filter.ServeHTTP(recorder, request)
	response := recorder.Result()

	assert.Equal(t, 503, response.StatusCode)
	contents, err := ioutil.ReadAll(response.Body)
	assert.NoError(t, err)
	assert.True(
		t,
		strings.Contains(string(contents), "Service Not Ready"),
		"content is: "+string(contents),
	)
}

func TestMonitorFilterBadServiceName(t *testing.T) {
	mon := MinMonitor{}
	_, err := mon.NewMinMonitorFilter("unknown_service")
	assert.Error(t, err)
}

type counterTriggerrer struct {
	count int
}

func (th *counterTriggerrer) Trigger() error {
	if th.count < 0 {
		return errors.New("this trigger always errors")
	}

	th.count++
	return nil
}

func TestMonitorFilterUpTriggers(t *testing.T) {
	request, err := http.NewRequest("GET", "http://localhost", nil)
	assert.NoError(t, err)

	testServiceName := "test"

	u, s, err := getUpService(t)
	assert.NoError(t, err)
	defer recycleUpService(s)

	gracePeriod := time.Duration(0)

	onDown := &counterTriggerrer{}
	onUp := &counterTriggerrer{}
	always := &counterTriggerrer{}

	service := &MinMonitorredService{
		URL: u,
		GracePeriod: gracePeriod,
		OnDown: onDown,
		OnUp: onUp,
		Always: always,
	}
	assert.NoError(t, err)
	mon := MinMonitor{}
	err = mon.Add(
		testServiceName,
		service,
	)
	assert.NoError(t, err)

	filter, err := mon.NewMinMonitorFilter(
		testServiceName,
	)
	assert.NoError(t, err)

	recorder := httptest.NewRecorder()
	filter.ServeHTTP(recorder, request)
	response := recorder.Result()

	assert.Equal(t, 200, response.StatusCode)
	contents, err := ioutil.ReadAll(response.Body)
	assert.NoError(t, err)
	assert.True(
		t,
		strings.Contains(string(contents), "Pullcord Landing Page"),
		"content is: "+string(contents),
	)
	assert.Equal(t, 0, onDown.count)
	assert.Equal(t, 1, onUp.count)
	assert.Equal(t, 1, always.count)
}

func TestMonitorFilterDownTriggers(t *testing.T) {
	request, err := http.NewRequest("GET", "http://localhost", nil)
	assert.NoError(t, err)

	testServiceName := "test"

	u, err := getDownService(t)
	assert.NoError(t, err)

	gracePeriod := time.Duration(0)

	onDown := &counterTriggerrer{}
	onUp := &counterTriggerrer{}
	always := &counterTriggerrer{}

	svc := &MinMonitorredService{
		URL: u,
		GracePeriod: gracePeriod,
		OnDown: onDown,
		OnUp: onUp,
		Always: always,
	}
	assert.NoError(t, err)
	mon := MinMonitor{}
	err = mon.Add(
		testServiceName,
		svc,
	)
	assert.NoError(t, err)

	filter, err := mon.NewMinMonitorFilter(
		testServiceName,
	)
	assert.NoError(t, err)

	recorder := httptest.NewRecorder()
	filter.ServeHTTP(recorder, request)
	response := recorder.Result()

	assert.Equal(t, 503, response.StatusCode)
	contents, err := ioutil.ReadAll(response.Body)
	assert.NoError(t, err)
	assert.True(
		t,
		strings.Contains(string(contents), "Service Not Ready"),
		"content is: "+string(contents),
	)
	assert.Equal(t, 1, onDown.count)
	assert.Equal(t, 0, onUp.count)
	assert.Equal(t, 1, always.count)
}

func TestMonitorFilterUpOnUpTriggerError(t *testing.T) {
	request, err := http.NewRequest("GET", "http://localhost", nil)
	assert.NoError(t, err)

	testServiceName := "test"

	u, s, err := getUpService(t)
	assert.NoError(t, err)
	defer recycleUpService(s)

	gracePeriod := time.Duration(0)

	onDown := &counterTriggerrer{}
	onUp := &counterTriggerrer{-1}
	always := &counterTriggerrer{}

	service := &MinMonitorredService{
		URL: u,
		GracePeriod: gracePeriod,
		OnDown: onDown,
		OnUp: onUp,
		Always: always,
	}
	assert.NoError(t, err)
	mon := MinMonitor{}
	err = mon.Add(
		testServiceName,
		service,
	)
	assert.NoError(t, err)

	filter, err := mon.NewMinMonitorFilter(
		testServiceName,
	)
	assert.NoError(t, err)

	recorder := httptest.NewRecorder()
	filter.ServeHTTP(recorder, request)
	response := recorder.Result()

	assert.Equal(t, 500, response.StatusCode)
	contents, err := ioutil.ReadAll(response.Body)
	assert.NoError(t, err)
	assert.True(
		t,
		strings.Contains(string(contents), "Internal Server Error"),
		"content is: "+string(contents),
	)
	assert.Equal(t, -1, onUp.count)
}

func TestMonitorFilterDownOnDownTriggerError(t *testing.T) {
	request, err := http.NewRequest("GET", "http://localhost", nil)
	assert.NoError(t, err)

	testServiceName := "test"

	u, err := getDownService(t)
	assert.NoError(t, err)

	gracePeriod := time.Duration(0)

	onDown := &counterTriggerrer{-1}
	onUp := &counterTriggerrer{}
	always := &counterTriggerrer{}

	svc := &MinMonitorredService{
		URL: u,
		GracePeriod: gracePeriod,
		OnDown: onDown,
		OnUp: onUp,
		Always: always,
	}
	assert.NoError(t, err)
	mon := MinMonitor{}
	err = mon.Add(
		testServiceName,
		svc,
	)
	assert.NoError(t, err)

	filter, err := mon.NewMinMonitorFilter(
		testServiceName,
	)
	assert.NoError(t, err)

	recorder := httptest.NewRecorder()
	filter.ServeHTTP(recorder, request)
	response := recorder.Result()

	assert.Equal(t, 500, response.StatusCode)
	contents, err := ioutil.ReadAll(response.Body)
	assert.NoError(t, err)
	assert.True(
		t,
		strings.Contains(string(contents), "Internal Server Error"),
		"content is: "+string(contents),
	)
	assert.Equal(t, -1, onDown.count)
}

func TestMonitorFilterDownAlwaysTriggerError(t *testing.T) {
	request, err := http.NewRequest("GET", "http://localhost", nil)
	assert.NoError(t, err)

	testServiceName := "test"

	u, err := getDownService(t)
	assert.NoError(t, err)

	gracePeriod := time.Duration(0)

	onDown := &counterTriggerrer{}
	onUp := &counterTriggerrer{}
	always := &counterTriggerrer{-1}

	svc := &MinMonitorredService{
		URL: u,
		GracePeriod: gracePeriod,
		OnDown: onDown,
		OnUp: onUp,
		Always: always,
	}
	assert.NoError(t, err)
	mon := MinMonitor{}
	err = mon.Add(
		testServiceName,
		svc,
	)
	assert.NoError(t, err)

	filter, err := mon.NewMinMonitorFilter(
		testServiceName,
	)
	assert.NoError(t, err)

	recorder := httptest.NewRecorder()
	filter.ServeHTTP(recorder, request)
	response := recorder.Result()

	assert.Equal(t, 500, response.StatusCode)
	contents, err := ioutil.ReadAll(response.Body)
	assert.NoError(t, err)
	assert.True(
		t,
		strings.Contains(string(contents), "Internal Server Error"),
		"content is: "+string(contents),
	)
	assert.Equal(t, -1, always.count)
}

func TestMinMonitorFromConfig(t *testing.T) {
	test := configutil.ConfigTest{
		ResourceType: "minmonitorredservice",
		SyntacticallyBad: []configutil.ConfigTestData{
			{
				Data:        "",
				Explanation: "empty config",
			},
			{
				Data:        "{}",
				Explanation: "empty object",
			},
			{
				Data:        "null",
				Explanation: "null config",
			},
			{
				Data:        "42",
				Explanation: "numeric config",
			},
		},
		Good: []configutil.ConfigTestData{
			{
				Data: `{
					"address": "127.0.0.1",
					"port": 80,
					"protocol": "http",
					"graceperiod": "1s"
				}`,
				Explanation: "basic valid monitor config",
			},
		},
	}
	test.Run(t)
}
